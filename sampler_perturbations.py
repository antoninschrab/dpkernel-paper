"""
Vectorised JAX version of the sampler of:
MMD Aggregated Two-Sample Test
Antonin Schrab, Ilmun Kim, Melisande Albert, Beatrice Laurent, Benjamin Guedj, Arthur Gretton
https://www.jmlr.org/papers/volume24/21-1289/21-1289.pdf
https://github.com/antoninschrab/mmdagg-paper
"""

import jax
import jax.numpy as jnp
from jax import vmap, random, jit, lax
from jax.flatten_util import ravel_pytree
from functools import partial
import itertools


def G(x):
    """
    Function G.
    
    Parameters
    ----------
    x: scalar
        Real number.
        
    Returns
    -------
    output: scalar
        Real number computed as
        exp(-1 / (1 - (4 * x + 3) ** 2)) if -1 < x < -0.5,
        - exp(-1 / ( 1 - (4 * x + 1) ** 2)) if -0.5 < x < 0,
        0 otherwise.
    """
    output = jax.lax.cond(
        jnp.logical_and(-1 < x, x < 0), 
        lambda: jax.lax.cond(
            jnp.logical_and(-1 < x, x < -0.5), 
            lambda: jnp.exp(-1 / (1 - (4 * x + 3) ** 2)), 
            lambda: - jnp.exp(-1 / ( 1 - (4 * x + 1) ** 2)),
        ),
        lambda: 0.,
    )
    return output 


def G_step(x):
    """
    Function G simplified (two step functions).
    
    Parameters
    ----------
    x: scalar
        Real number.
        
    Returns
    -------
    output: scalar
        Real number computed as
        exp(-1) if -1 < x < -0.5,
        - exp(-1) if -0.5 < x < 0,
        0 otherwise.
    """
    output = jax.lax.cond(
        jnp.logical_and(-1 < x, x < 0), 
        lambda: jax.lax.cond(
            jnp.logical_and(-1 < x, x < -0.5), 
            lambda: jnp.exp(-1), 
            lambda: - jnp.exp(-1),
        ),
        lambda: 0.,
    )
    return output 


def f_theta(x, p, s, perturbation_multiplier=1, step=False):
    """
    Function f_theta (perturbed uniform density).
    
    Parameters
    ----------
    x: array_like
        Array of shape (d,) (point in R^d).
    p: int
        Number of perturbations per dimension.
    s: scalar
        Positive smoothness parameter of Sobolev ball.
    perturbation_multiplier: scalar
        Positive number scaling the perturbations.
    step: bool
        If True use the function G_step as perturbation.
        If True use the function G as perturbation.
        
    Returns
    -------
    output: scalar
        Real number corresponding to f_theta(x).
    """
    d = x.shape[0]
    # set {1,...,p}^d
    I = list(itertools.product([i + 1 for i in range(p)], repeat=d))  
    
    # for i in range(len(I)):
    #     output += jnp.prod(jnp.array([G(x[r] * p - I[i][r]) for r in range(d)]))   
    I = jnp.array(I)
    if step:
        compute_prod = lambda i : jnp.prod(
            lax.map(lambda r : G_step(x[r] * p - I[i, r]), jnp.arange(d))
        )        
    else:
        compute_prod = lambda i : jnp.prod(
            lax.map(lambda r : G(x[r] * p - I[i, r]), jnp.arange(d))
        )
    output = jnp.sum(lax.map(compute_prod, jnp.arange(len(I))))

    output *= p ** (-s) * perturbation_multiplier
    
    # if np.min(x) >= 0 and np.max(x) <= 1:
    #     output += 1
    output += jax.lax.cond(
        jnp.logical_and(jnp.min(x) >= 0, jnp.max(x) <= 1), 
        lambda: 1.,
        lambda: 0.,
    )
    return output


# https://github.com/google/jax/discussions/11219
def sample_fun(key, function, num_samples, d, ymax):
    """
    Rejection sampler on [0, 1]^d.
    
    Parameters
    ----------
    key:
        Jax random key (can be generated by jax.random.PRNGKey(seed) for an integer seed).
    function: function
        Probability density function (input array and output scalar).
    num_samples: int
        Number of samples.
    d: int
        Dimension.
    ymax: scalar
        Upper bound on function.
        
    Returns
    -------
    output: array_like
        Array of shape (num_samples, d) corresponding to
        samples from function.
    """
     def rejection_sample(args):
        key, all_x, i = args
        key, subkey = jax.random.split(key)
        x = jax.random.uniform(
            subkey, 
            minval=0, 
            maxval=1, 
            shape=(d,),
        )
        key, subkey = jax.random.split(key)
        y = jax.random.uniform(
            subkey, 
            minval=0, 
            maxval=ymax, 
            shape=(1,),
        )

        passed = (y < function(x)).astype(bool)
        all_x = all_x.at[i].set(x)
        i = i + passed[0]
        return key, all_x, i
     X_init = jnp.zeros((num_samples, d))
     _, X, _ = jax.lax.while_loop(
         lambda args: args[2] < num_samples, 
         rejection_sample, 
         (key, X_init, 0),
     )
     return X


@partial(jit, static_argnums=(1, 2, 3, 4, 5, 6))
def sampler_perturbed_uniform(
    key,
    num_random,
    num_samples,
    d,
    number_perturbations,
    scale=1,
    step=False,
):
    """
    Rejection sampler on [0, 1]^d.
    
    Parameters
    ----------
    key:
        Jax random key (can be generated by jax.random.PRNGKey(seed) for an integer seed).
    num_random: int
        Number of repetitions.
    num_samples: int
        Number of samples.
    d: int
        Dimension.
    number_perturbations: int
        Number of perturbations.
    scale: scalar
        Amplitude of the perturbations.
    step: bool
        If True use the function G_step as perturbation.
        If True use the function G as perturbation.
        
    Returns
    -------
    output: array_like
        Array of shape (num_random, num_samples, d) 
        corresponding to samples from f_theta.
    """
    sample_fun_vmap = jit(
        partial(
            vmap(sample_fun, in_axes=(0, None, None, None, None))
        ),
        static_argnums=(1, 2, 3, 4),
    )
    p = number_perturbations
    
    # stretch the perturbation to have amplitude 1 * scale
    s = 1 
    perturbation_multiplier = jnp.exp(d) * p ** s * scale 
    
    function = lambda x : f_theta(
        x, 
        p, 
        s, 
        perturbation_multiplier,
        step=step,
    )
    ymax = 1 + scale
    
    keys = random.split(key, num=num_random)
    return sample_fun_vmap(keys, function, num_samples, d, ymax)


def sampler_perturb_2ST(
    key,
    m,
    n,
    d,
    num_random,
    num_perturbations,
    scale=1,
    step=False,
):
    """
    Perturbed uniform sampler for two-sample testing.
    
    Parameters
    ----------
    key:
        Jax random key (can be generated by jax.random.PRNGKey(seed) for an integer seed).
    m: int
        Number of samples for X (perturbed uniform distribution).
    n: int
        Number of samples for Y (uniform distribution).
    d: int
        Dimension.
    num_random: int
        Number of repetitions.
    num_perturbations: int
        Number of perturbations.
    scale: scalar
        Amplitude of the perturbations.
    step: bool
        If True use the function G_step as perturbation.
        If True use the function G as perturbation.
        
    Returns
    -------
    output: tuple
        tuple (X, Y) where
            X: array_like
                Array of shape (m, d) consisting of samples from perturbed uniform distribution.
            Y: array_like
                Array of shape (n, d) consisting of samples from uniform distribution.
    """
    if num_perturbations > 0:
        keys = random.split(key, num=3)
        X = sampler_perturbed_uniform(
            keys[0],
            num_random=num_random,
            num_samples=m,
            d=1,
            number_perturbations=num_perturbations,
            scale=scale,
            step=step,
        )
        if d > 1:
            X_extra = random.uniform(keys[1], shape=(num_random, m, d - 1))
            X = jnp.concatenate((X, X_extra), -1)
        Y = random.uniform(keys[2], shape=(num_random, n, d))
    else: 
        keys = random.split(key, num=2)
        X = random.uniform(keys[0], shape=(num_random, m, d))
        Y = random.uniform(keys[1], shape=(num_random, n, d))
    return X, Y


def sampler_perturb_IndT(
    key,
    m,
    dX,
    dY,
    num_random,
    num_perturbations,
    scale=1,
    step=False,
):
    """
    Perturbed uniform sampler for independence testing.
    
    Parameters
    ----------
    key:
        Jax random key (can be generated by jax.random.PRNGKey(seed) for an integer seed).
    m: int
        Number of samples.
    dX: int
        Dimension for X.
    dY: int
        Dimension for Y.
    num_random: int
        Number of repetitions.
    num_perturbations: int
        Number of perturbations.
    scale: scalar
        Amplitude of the perturbations.
    step: bool
        If True use the function G_step as perturbation.
        If True use the function G as perturbation.
        
    Returns
    -------
    output: tuple
        tuple (X, Y) where Z = concatenate(X, Y) is an array of shape
        (m, dX + dY) consisting of samples from perturbed uniform distribution.
    """
    if num_perturbations > 0:
        keys = random.split(key, num=3)
        d = dX + dY
        Z = sampler_perturbed_uniform(
            key=keys[0],
            num_random=num_random,
            num_samples=m,
            d=2,
            number_perturbations=num_perturbations,
            scale=scale,
            step=step,
        )
        X = Z[:, :, :1]
        Y = Z[:, :, 1:]
        if dX > 1:
            X_extra = random.uniform(keys[1], shape=(num_random, m, dX - 1))
            X = jnp.concatenate((X, X_extra), -1)
        if dY > 1:
            Y_extra = random.uniform(keys[2], shape=(num_random, m, dY - 1))
            Y = jnp.concatenate((Y, Y_extra), -1)
        return X, Y
    else:
        keys = random.split(key, num=2)
        X = random.uniform(keys[0], shape=(num_random, m, dX))
        Y = random.uniform(keys[1], shape=(num_random, m, dY))
        return X, Y
